<?php

/**
 * Log
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    tf2logs
 * @subpackage model
 * @author     Brian Barnekow
 */
class Log extends BaseLog
{
  protected $_timeStart;
  protected $_scrubbedLog = "";
  protected $_events;
  
  public function getEventsArray($clearArray = false) {
    $ret = $this->_events;
    if($clearArray) $this->_events = array();
    return $ret;
  }
  
  public function set_timeStart($timeStart) {
    $this->_timeStart = $timeStart;
  }
  
  public function get_timeStart() {
    return $this->_timeStart;
  }
  
  public function appendToScrubbedLog($logLine) {
    if($this->getLogFile() == null) $this->setLogFile(new LogFile());
    $this->getLogFile()->appendString($logLine);
  }
  
  
  /**
  * Adds a stat record for the given player, if unique.
  */
  public function addUpdateUniqueStatFromPlayerInfo(PlayerInfo $playerInfo) {
    if(isset($this->Stats[$playerInfo->getSteamid()])) {
      $stat = $this->Stats[$playerInfo->getSteamid()];
      //no need to add, but will update here.
      
      //if the player is now on team null (discon, spec, etc) keep old team designation.
      if($playerInfo->getTeam() == null) {
        $playerInfo->setTeam($stat->getTeam());
      }
      
      $stat->setPlayerInfoAttributes($playerInfo);
    } else if($playerInfo->getSteamid() != "Console" && $playerInfo->getTeam() != null) {
      //no need to track the console's stats, and do not add a player unless an ingame action occurs
      //otherwise, add the player.
      $stat = new Stat();
      $stat->setPlayerInfoAttributes($playerInfo);
      $this->Stats[$playerInfo->getSteamid()] = $stat;
    }
  }
  
  /**
  * For an array of given PlayerInfo objects, will add the unique players.
  */
  public function addUpdateUniqueStatsFromPlayerInfos($playerInfos) {
    foreach($playerInfos as $key => $pi) {
      if(!($pi instanceof PlayerInfo)) {
        throw new InvalidArgumentException("playerInfos given to addUniqueStatsFromPlayerInfos must be of PlayerInfo type.");
      }
      
      $this->addUpdateUniqueStatFromPlayerInfo($pi);
    }
  }
  
  public function incrementStatFromSteamid($steamid, $statkey, $increment = 1) {
    $stat = &$this->getStatFromSteamid($steamid);
    if($stat === false) throw new InvalidArgumentException("steamid could not be found in incrementStatFromSteamid: $steamid, $statkey");
    $stat->incrementStat($statkey, $increment);
  }
  
  /**
  * Sets the given team's score to the given value.
  */
  public function setScoreForTeam($team, $score) {
    if($team == "Red") $this->setRedscore($score);
    else if($team == "Blue") $this->setBluescore($score);
    else throw new InvalidArgumentException("Invalid team '$team' given to setScoreForTeam method.");
  }
  
  /**
  * Increments the given team's score
  */
  public function incrementScoreForTeam($team, $increment = 1) {
    if($team == "Red") $this->setRedscore($this->getRedscore()+$increment);
    else if($team == "Blue") $this->setBluescore($this->getBluescore()+$increment);
    else throw new InvalidArgumentException("Invalid team '$team' given to incrementScoreForTeam method.");
  }
  
  /**
  * This will switch the red and blue scores around. Used when teams are switched.
  */
  public function switchScores() {
    $red = $this->getRedscore();
    $this->setRedscore($this->getBluescore());
    $this->setBluescore($red);
  }
  
  /**
  * This will add the weapon to the steamid.
  */
  public function incrementWeaponForPlayer($steamid, $weapon, $propertyToIncrement, $increment = 1) {
    $stat = &$this->getStatFromSteamid($steamid);
    if($stat === false) throw new InvalidArgumentException("steamid could not be found in addWeaponToSteamid: $steamid, $weapon");
    $stat->incrementWeaponForPlayer($weapon, $propertyToIncrement, $increment);
  }
  
  /**
  * This will add the role to the steamid.
  */
  public function addRoleToSteamid($steamid, $role, $nowDt, $logStartDt) {
    $stat = &$this->getStatFromSteamid($steamid);
    if($stat === false) throw new InvalidArgumentException("steamid could not be found in addRoleToSteamid: $steamid, $role, $nowDt, $logStartDt");
    $stat->addRoleToPlayer($role, $nowDt, $logStartDt);
  }
  
  public function addPlayerStatToSteamid($attackerSteamid, $otherSteamid, $propertyToIncrement, $increment = 1) {
    $attackerStat = &$this->getStatFromSteamid($attackerSteamid);
    $otherStat = $this->getStatFromSteamid($otherSteamid);
    if($attackerStat === false || $otherStat === false) throw new InvalidArgumentException("steamid could not be found in addPlayerStatToSteamid: $attackerSteamid,  $otherSteamid, $propertyToIncrement, $increment");
    $attackerStat->addPlayerStat($otherStat->getPlayer(), $propertyToIncrement, $increment);
  }
  
  public function addPlayerHealStatToSteamid($healerSteamid, $otherSteamid, $increment) {
    $healerStat = &$this->getStatFromSteamid($healerSteamid);
    $otherStat = $this->getStatFromSteamid($otherSteamid);
    if($healerStat === false || $otherStat === false) throw new InvalidArgumentException("steamid could not be found in addPlayerHealStatToSteamid: $healerSteamid,  $otherSteamid, $increment");
    $healerStat->addPlayerHealStat($otherStat->getPlayer(), $increment);
  }
  
  public function addItemPickupStatToSteamid($playerSteamid, $itemKeyName, $increment = 1) {
    $playerStat = &$this->getStatFromSteamid($playerSteamid);
    if($playerStat === false) throw new InvalidArgumentException("steamid could not be found in addItemPickupStatToSteamid: $playerSteamid $itemKeyName, $increment");
    $playerStat->addItemPickupStat($itemKeyName, $increment);
  }
  
  public function addKillEvent($elapsedSeconds, $weaponId, $attackerSteamid, $attackerCoord, $victimSteamid, $victimCoord) {
    $attackerStat = $this->getStatFromSteamid($attackerSteamid);
    $victimStat = $this->getStatFromSteamid($victimSteamid);
    $this->_events[] = Event::kill($elapsedSeconds, $weaponId, $attackerStat->getPlayerId(), $attackerCoord, $victimStat->getPlayerId(), $victimCoord);
  }
  
  public function markLastKillEventWithAssist($assistSteamid, $assistCoord) {
    $eCount = count($this->_events);
    if($this->_events && $eCount > 0) {
      $e = &$this->_events[$eCount-1];
      if($e['event_type'] == "kill") {
        $assistStat = $this->getStatFromSteamid($assistSteamid);
        Event::assist($e, $assistStat->getPlayerId(), $assistCoord);
      }
    } else {
      //this case, where there is no events and an assist came through, is likely due to linebyline processing, though a log could conceivably start with this as well.
      $e = array('updateLastKillEvent' => true);
      $assistStat = $this->getStatFromSteamid($assistSteamid);
      Event::assist($e, $assistStat->getPlayerId(), $assistCoord);
      $this->_events[] = $e;
    }
  }
  
  public function addPointCaptureEvent($elapsedSeconds, $players, $team, $capturePoint) {
    $pids = array();
    foreach($players as $p) {
      $stat = $this->getStatFromSteamid($p->getSteamid());
      $pids[] = $stat->getPlayerId();
    }
    
    $this->_events[] = Event::pointCapture($elapsedSeconds, $pids, $team, $capturePoint);
  }
  
  public function addChatEvent($elapsedSeconds, $chatType, $chatPlayer, $text) {
    $chatStat = $this->getStatFromSteamid($chatPlayer->getSteamid());
    if($chatStat == null) {
      $this->addUpdateUniqueStatFromPlayerInfo($chatPlayer);
      $chatStat = $this->getStatFromSteamid($chatPlayer->getSteamid());
    }
    
    //if we still don't have a chatStat, its because it could not be added, due to it being Console or not on team.
    if($chatStat != null) {
      $this->_events[] = Event::chat($elapsedSeconds, $chatType, $chatStat->getPlayerId(), $text);
    }
  }
  
  public function addRoundStartEvent($elapsedSeconds, $blueScore, $redScore) {
    $this->_events[] = Event::roundStart($elapsedSeconds, $blueScore, $redScore);
  }
  
  public function addScoreChangeEvent($elapsedSeconds, $blueScore, $redScore) {
    $this->_events[] = Event::scoreChange($elapsedSeconds, $blueScore, $redScore);
  }
  
  /**
  * Used to perform any last cleanup work.
  */
  public function finishLog($nowDt, $logStartDt) {    
    //call finishStat for all stats.
    $steamids = array();
    foreach($this->Stats as &$stat) {
      $stat->finishStat($nowDt, $logStartDt);
      $steamids[] = $stat->getPlayer()->getNumericSteamid();
    }
    
    //update player avatar for stats.
    $swapi = new SteamWebAPI();
    $a = $swapi->getAvatarUrlsFromSteamids($steamids);
    foreach($this->Stats as &$stat) {
      foreach($a as $avatarurl) {
        $steamid = array_keys($avatarurl);
        $steamid = $steamid[0];
        if($stat->getPlayer()->getNumericSteamid() == $steamid) {
          $url = $avatarurl[$steamid];
          $stat->getPlayer()->setAvatarUrl($url);
          break;
        }
      }
    }
  }
  
  public function finishStatForSteamid($steamid, $nowDt, $logStartDt) {
    $stat = &$this->getStatFromSteamid($steamid);
    if($stat !== false) $stat->finishStat($nowDt, $logStartDt);
  }
  
  public function clearLog() {
    $this->redscore = 0;
    $this->bluescore = 0;
    $this->elapsed_time = 0;
    $this->error_log_name = null;
    $this->error_exception = null;
    $this->LogFile->log_data = "";
    $this->clearStats();
    $this->clearEvents();
  }
  
  public function clearStats() {
    $this->Stats->delete();
  }
  
  public function clearEvents() {
    $this->Events->delete();
  }
  
  /**
  * Gets a stat by reference by steamid. Protected since 
  * allowing the end user of the class to update the stat
  * outside of this class is unwise.
  */
  protected function &getStatFromSteamid($steamid) {
    if(!isset($this->Stats[$steamid])) {
      $ret = false;
      return $ret;
    }
    $f = &$this->Stats[$steamid];
    return $f;
  }
}
